package com.tschuchort.kotlinelements

import me.eugeniomarletti.kotlin.metadata.*
import me.eugeniomarletti.kotlin.metadata.shadow.metadata.deserialization.NameResolver
import javax.annotation.processing.ProcessingEnvironment
import javax.lang.model.AnnotatedConstruct
import javax.lang.model.element.*
import javax.lang.model.type.TypeMirror
import javax.lang.model.util.Elements
import javax.tools.Diagnostic

/**
 * A static Kotlin- or Java-language level construct that originates from Kotlin source code.
 *
 * That means either an javaElement representing a syntactic construct in Kotlin source code
 * ([KotlinElement]) or a Java-[Element] that was generated by the Kotlin compiler but is
 * not accessible from Kotlin code and has no 1:1 correspondence to a syntactic
 * construct in Kotlin code ([KotlinCompatElement])
 */
sealed class KotlinRelatedElement

/**
 * A JVM-[Element] that was generated by the Kotlin compiler for
 * Java compatibility or implementation purposes and has no 1:1 correspondence
 * to a syntactic construct in Kotlin source code and is not accessible from
 * Kotlin source code either (in contrast to generated elements like default constructors
 * that are accessible from Kotlin source code)
 *
 * Since the javaElement itself never appears explicitly in Kotlin source code, it is
 * not considered a [KotlinElement]
 *
 * Those elements are not necessarily [Elements.Origin.MANDATED] because they are sometimes
 * generated by explicit annotations like [JvmOverloads]
 */
abstract class KotlinCompatElement(
		open val javaElement: Element, processingEnv: ProcessingEnvironment
) : KotlinRelatedElement(), AnnotatedConstruct by javaElement {

	open val enclosingElement: KotlinRelatedElement by lazy {
		javaElement.enclosingElement!!.asKotlin(processingEnv)!!
	}

	open fun asType(): TypeMirror = javaElement.asType()

	final override fun toString(): String = javaElement.toString()
	final override fun equals(other: Any?): Boolean = other?.let { javaElement.equals(it) } ?: false
	final override fun hashCode(): Int = javaElement.hashCode()
}

/**
 * Represents a syntax element such as a class, method, typealias, and so on
 * in the Kotlin source code.
 *
 * This includes compiler generated elements that are directly accessible
 * from Kotlin code but not those that are generated by the Kotlin compiler
 * for Java-compatibility or implementation purposes such as jvm overloads of a method,
 * fields, file facade classes, interface default implementations and so on
 *
 * Not every [KotlinElement] is necessarily backed by at least one Java-[Element]
 * (type aliases in particular) and not every [KotlinElement] that is corresponds
 * to only a single Java-[Element] (for example: methods with @[JvmOverloads] annotation)
 */
abstract class KotlinElement internal constructor(
		protected val processingEnv: ProcessingEnvironment
) : KotlinRelatedElement(), AnnotatedConstruct {
	companion object {
		/** Returns the [NameResolver] of the closest parent javaElement (or this javaElement) that has one */
		internal fun getNameResolver(elem: Element): NameResolver? {
			val metadata = elem.kotlinMetadata
			return when(metadata) {
				is KotlinPackageMetadata -> metadata.data.nameResolver
				is KotlinClassMetadata -> metadata.data.nameResolver
				else -> elem.enclosingElement?.let(::getNameResolver)
			}
		}

		/** Returns the [KotlinMetadata] of the closest parent javaElement (or this javaElement) that has one */
		internal fun getMetadata(elem: Element): KotlinMetadata?
				= elem.kotlinMetadata ?: elem.enclosingElement?.let(::getMetadata)
	}

	abstract val enclosingElement: KotlinElement?

	abstract val simpleName: Name

	abstract fun asType(): TypeMirror

	//TODO("visitor API")

	protected fun logW(s: String) = processingEnv.messager.printMessage(Diagnostic.Kind.WARNING, s)

	abstract override fun toString(): String
	abstract override fun equals(other: Any?): Boolean
	abstract override fun hashCode(): Int
}

/**
 * Returns the JVM signature in the form "$Name$MethodDescriptor", for example: `equals(Ljava/lang/Object;)Z`.
 *
 * For reference, see the [JVM specification, section 4.3](http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.3).
 */
internal fun ExecutableElement.getJvmMethodSignature(processingEnv: ProcessingEnvironment): String
		= with(processingEnv.kotlinMetadataUtils) {
	this@getJvmMethodSignature.jvmMethodSignature
}

/**
 * Whether this javaElement originates from Kotlin code. It doesn't actually have to be
 * a [KotlinElement], it may as well be a [KotlinCompatElement] that was generated
 * by the compiler for Java-interop
 */
internal fun Element.originatesFromKotlinCode(): Boolean {
	return if(kotlinMetadata != null)
		true
	else when(this.kind) {
		ElementKind.CLASS,
		ElementKind.ENUM,
		ElementKind.INTERFACE,
		ElementKind.ANNOTATION_TYPE,
		ElementKind.PACKAGE -> false

		ElementKind.MODULE -> enclosedElements.any { originatesFromKotlinCode() }  //TODO("check module metadata instead")

		ElementKind.OTHER -> throw UnsupportedOperationException("Encountered unknown element kind")

		else -> enclosingElement?.originatesFromKotlinCode() ?: false
	}
}

