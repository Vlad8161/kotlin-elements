package com.tschuchort.kotlinelements

import java.util.*
import javax.annotation.processing.ProcessingEnvironment
import javax.lang.model.element.*

/**
 *  A [KotlinExecutableElement] corresponds to a single method, free function or constructor
 *  in Kotlin source code, but may correspond to several Java [ExecutableElement]s that are
 *  generated when @[JvmOverloads] is used
 */
/*abstract class KotlinExecutableElement internal constructor(
		/**
		 * the Java method associated with this Kotlin method or the one that
		 * has the same signature (all parameters) if there are multiple associated
		 * Java elements generated by @[JvmOverloads]
		 */
		val javaElement: ExecutableElement,
		/**
		 * java method elements that were generated by @[JvmOverloads] and have
		 * less parameters than the Kotlin method
		 */
		val jvmOverloadElements: List<ExecutableElement>,
		processingEnv: ProcessingEnvironment
) : KotlinSubelement(processingEnv), ExecutableElement by javaElement, KotlinParameterizable {

	init {
		if(jvmOverloadElements.isNotEmpty())
			// check that all the javaElements associated with this Kotlin ExecutableElement...
			with(jvmOverloadElements + javaElement) {
				// ...have the same return type
				require(allEqualBy(ExecutableElement::getReturnType))

				// ...have the same receiver type
				require(allEqualBy(ExecutableElement::getReceiverType))

				// ...have the same name
				require(allEqualBy(ExecutableElement::getSimpleName))

				// ...have the same enclosing element
				require(allEqualBy(ExecutableElement::getEnclosingElement))

				// ...none enclose elements
				assert(all { it.enclosedElements.isEmpty() })

				// Unfortunately @JvmOverloads has RetentionPolicy.BINARY so we can not check that
				// the elements actually have a @JvmOverloads annotation if there are multiple
			}
	}

	/**
	 * Whether this Kotlin executable element has multiple JVM overloads, i.e.
	 * the list of [jvmOverloadElements] is non-empty
	 */
	val hasJvmOverloads: Boolean = jvmOverloadElements.isNotEmpty()

	//TODO("handle Kotlin receiver type")

	//TODO("handle Kotlin thrown types")

	//TODO("return KotlinVariableElement parameters")

	//TODO("handle Kotlin return types")

	override fun getEnclosingElement(): KotlinElement
			=  javaElement.enclosingElement.let {
		it.toKotlinElement(processingEnv)
		?: throw IllegalStateException("Enclosing element \"$it\" " +
									   "of \"$this\" is not a KotlinElement")
	}

	override fun getEnclosedElements(): List<Nothing> {
		// According to documentation (as of JDK 9), an ExecutableElement
		// is not considered to enclose any elements
		assert(javaElement.enclosedElements.isNotEmpty())
		return emptyList()
	}

	abstract override fun getTypeParameters(): List<KotlinTypeParameterElement>

	override fun equals(other: Any?)
		= (other is KotlinExecutableElement
		   && other.javaElement.jvmSignature() == javaElement.jvmSignature()
		   && other.enclosingElement == enclosingElement)

	override fun hashCode() = Objects.hash(simpleName, enclosingElement, javaElement.jvmSignature())

	override fun toString() = javaElement.toString()
}*/