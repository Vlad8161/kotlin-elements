package com.tschuchort.kotlinelements

import java.util.*
import javax.annotation.processing.ProcessingEnvironment
import javax.lang.model.AnnotatedConstruct
import javax.lang.model.element.*
import javax.lang.model.type.TypeMirror

/**
 *  A [KotlinExecutableElement] corresponds to a single method, free function or constructor
 *  in Kotlin source code, but may correspond to several Java [ExecutableElement]s that are
 *  generated when @[JvmOverloads] is used
 */
abstract class KotlinExecutableElement internal constructor(
		/**
		 * the Java method associated with this Kotlin method or the one that
		 * has the same signature (all parameters) if there are multiple associated
		 * Java elements generated by @[JvmOverloads]
		 */
		val javaElement: ExecutableElement,
		javaOverloadElements: List<ExecutableElement>,
		override val enclosingElement: KotlinElement,
		processingEnv: ProcessingEnvironment
) : KotlinElement(processingEnv), AnnotatedConstruct by javaElement {

	init {
		if(javaOverloadElements.isNotEmpty())
			// check that all the javaElements associated with this Kotlin ExecutableElement...
			with(javaOverloadElements + javaElement) {
				// ...have the same return type
				require(allEqualBy(ExecutableElement::getReturnType))

				// ...have the same receiver type
				require(allEqualBy(ExecutableElement::getReceiverType))

				// ...have the same name
				require(allEqualBy(ExecutableElement::getSimpleName))

				// ...have the same enclosing javaElement
				require(allEqualBy(ExecutableElement::getEnclosingElement))

				// ...none enclose elements
				assert(all { it.enclosedElements.isEmpty() })

				// Unfortunately @JvmOverloads has RetentionPolicy.BINARY so we can not check that
				// the elements actually have a @JvmOverloads annotation if there are multiple
			}
	}

	/**
	 * java method elements that were generated by @[JvmOverloads] and have
	 * less parameters than the Kotlin method
	 */
	val javaOverloads: List<JavaOverload> = javaOverloadElements.map(::JavaOverload)

	/**
	 * Returns the JVM signature in the form "$Name$MethodDescriptor", for example: `equals(Ljava/lang/Object;)Z`.
	 *
	 * For reference, see the [JVM specification, section 4.3](http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.3).
	 */
	val jvmSignature: String = javaElement.getJvmMethodSignature(processingEnv)

	/**
	 * Returns {@code true} if this method or constructor accepts a variable
	 * number of arguments and returns {@code false} otherwise.
	 *
	 * @return {@code true} if this method or constructor accepts a variable
	 * number of arguments and {@code false} otherwise
	 */
	val isVarArgs: Boolean = javaElement.isVarArgs

	/**
	 * The formal parameters of this executable.
	 * They are returned in declaration order.
	 *
	 * @return the formal parameters,
	 * or an empty list if there are none
	 */
	abstract val parameters: List<KotlinParameterElement>

	val receiverType: TypeMirror? = javaElement.receiverType //TODO("handle Kotlin receiver type")

	val thrownTypes: List<TypeMirror> = javaElement.thrownTypes //TODO("handle Kotlin thrown types")

	val returnType: TypeMirror = javaElement.returnType //TODO("handle Kotlin return types")

	override fun asType(): TypeMirror = javaElement.asType() //TODO("handle kotlin executable element asType")

	final override fun equals(other: Any?) = (other as? KotlinExecutableElement)?.javaElement == javaElement
	final override fun hashCode() = Objects.hash(javaElement)
	abstract override fun toString(): String

	inner class JavaOverload(override val javaElement: ExecutableElement)
		: KotlinCompatElement(javaElement, processingEnv) {

		override val enclosingElement: KotlinElement = this@KotlinExecutableElement.enclosingElement

		val correspondingFunction: KotlinExecutableElement = this@KotlinExecutableElement
	}
}