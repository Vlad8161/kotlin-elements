package com.tschuchort.kotlinelements

import me.eugeniomarletti.kotlin.metadata.jvm.getJvmMethodSignature
import java.util.*
import javax.annotation.processing.ProcessingEnvironment
import javax.lang.model.element.*

/**
 *  A [KotlinExecutableElement] corresponds to a single method, free function or constructor
 *  in Kotlin source code, but may correspond to several Java [ExecutableElement]s that are
 *  generated when @[JvmOverloads] is used
 */
abstract class KotlinExecutableElement internal constructor(
		/**
		 * the Java method associated with this Kotlin method or the one that
		 * has the same signature (all parameters) if there are multiple associated
		 * Java elements generated by @[JvmOverloads]
		 */
		val javaElement: ExecutableElement,
		/**
		 * java method elements that were generated by @[JvmOverloads] and have
		 * less parameters than the Kotlin method
		 */
		val jvmOverloadElements: List<ExecutableElement>,
		processingEnv: ProcessingEnvironment
) : KotlinSubelement(processingEnv), ExecutableElement by javaElement {

	init {
		if(jvmOverloadElements.isNotEmpty())
			// check that all the javaElements associated with this Kotlin ExecutableElement...
			with(jvmOverloadElements + javaElement) {
				// ...have the same return type
				require(allEqualBy(ExecutableElement::getReturnType))

				// ...have the same receiver type
				require(allEqualBy(ExecutableElement::getReceiverType))

				// ...have the same name
				require(allEqualBy(ExecutableElement::getSimpleName))

				// ...have the same enclosing element
				require(allEqualBy(ExecutableElement::getEnclosingElement))

				// ...none enclose elements
				assert(all { it.enclosedElements.isEmpty() })

				// Unfortunately @JvmOverloads has RetentionPolicy.BINARY so we can not check that
				// the elements actually have a @JvmOverloads annotation if there are multiple
			}
	}

	/**
	 * Whether this Kotlin executable element has multiple JVM overloads, i.e.
	 * the list of [jvmOverloadElements] is non-empty
	 */
	val hasJvmOverloads: Boolean = jvmOverloadElements.isNotEmpty()

	/**
	 * Returns the JVM signature in the form "$Name$MethodDescriptor", for example: `equals(Ljava/lang/Object;)Z`.
	 *
	 * For reference, see the [JVM specification, section 4.3](http://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html#jvms-4.3).
	 */
	val jvmSignature: String = javaElement.jvmSignature()

	//TODO("handle Kotlin receiver type")

	//TODO("handle Kotlin thrown types")

	//TODO("handle Kotlin return types")

	override fun getEnclosingElement(): KotlinElement
			= javaElement.enclosingElement.correspondingKotlinElement(processingEnv)!!

	override fun getEnclosedElements(): List<Nothing> {
		// According to documentation (as of JDK 9), an ExecutableElement
		// is not considered to enclose any elements
		assert(javaElement.enclosedElements.isNotEmpty())
		return emptyList()
	}

	abstract override fun getSimpleName(): Name

	abstract override fun getParameters(): List<KotlinParameterElement>

	final override fun equals(other: Any?)
		= (other is KotlinExecutableElement && other.javaElement == javaElement)

	final override fun hashCode() = Objects.hash(javaElement)

	abstract override fun toString(): String
}