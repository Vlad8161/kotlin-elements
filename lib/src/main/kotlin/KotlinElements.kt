package com.tschuchort.kotlinelements

import me.eugeniomarletti.kotlin.metadata.*
import me.eugeniomarletti.kotlin.metadata.shadow.metadata.deserialization.NameResolver
import javax.annotation.processing.ProcessingEnvironment
import javax.lang.model.AnnotatedConstruct
import javax.lang.model.element.*
import javax.lang.model.type.TypeMirror
import javax.lang.model.util.Elements
import javax.tools.Diagnostic

/**
 * A static Kotlin- or Java-language level construct that originates from Kotlin source code.
 *
 * That means either an element representing a syntactic construct in Kotlin source code
 * ([KotlinElement]) or a Java [Element] that was generated by the Kotlin compiler but is
 * not accessible from Kotlin code and has no 1:1 correspondence to a syntactic
 * construct in Kotlin code ([KotlinCompatElement])
 */
sealed class KotlinRelatedElement

/**
 * A Java [Element] that was generated by the Kotlin compiler for
 * Java compatibility or implementation purposes and has no 1:1 correspondence
 * to a syntactic construct in Kotlin source code and is not accessible from
 * Kotlin source code except through annotation use-site targets (in contrast
 * to generated elements like default constructors that are accessible from
 * Kotlin source code)
 *
 * Since the element itself never appears explicitly in Kotlin source code, it is
 * not considered a [KotlinElement]
 *
 * Those elements are not necessarily [Elements.Origin.MANDATED] because they
 * are sometimes generated by explicit annotations like @[JvmOverloads]
 */
abstract class KotlinCompatElement(
		protected val javaElement: Element, processingEnv: ProcessingEnvironment
) : KotlinRelatedElement(), Element {

	//TODO("resolve name conflict: enclosingElement")
	open val enclosingElement: KotlinRelatedElement by lazy {
		javaElement.enclosingElement!!.asKotlin(processingEnv)!!
	}

	final override fun toString(): String = javaElement.toString()
	final override fun equals(other: Any?): Boolean = javaElement.equals(other)
	final override fun hashCode(): Int = javaElement.hashCode()
}

/**
 * Unspecified [KotlinCompatElement]
 */
class UnspecifiedKotlinCompatElement(
		element: Element,
		processingEnv: ProcessingEnvironment
) : KotlinCompatElement(element, processingEnv), Element by element

/**
 * Represents a syntax element such as a class, method, typealias, and so on
 * in the Kotlin source code.
 *
 * This includes compiler generated elements that are directly accessible
 * from Kotlin code but not those that are generated by the Kotlin compiler
 * for Java-compatibility or implementation purposes such as java overloads of a method,
 * backing fields, file facade classes, interface default implementations and so on
 *
 * Not every [KotlinElement] is necessarily backed by at least one Java [Element]
 * (type aliases in particular) and not every [KotlinElement] that corresponds
 * to only a single Java [Element] (for example: methods with @[JvmOverloads] annotation)
 */
abstract class KotlinElement internal constructor(
		protected val processingEnv: ProcessingEnvironment
) : KotlinRelatedElement(), AnnotatedConstruct {
	companion object {
		/** Returns the [NameResolver] of the closest parent javaElement (or this javaElement) that has one */
		internal fun getNameResolver(elem: Element): NameResolver? {
			val metadata = elem.kotlinMetadata
			return when(metadata) {
				is KotlinPackageMetadata -> metadata.data.nameResolver
				is KotlinClassMetadata -> metadata.data.nameResolver
				else -> elem.enclosingElement?.let(::getNameResolver)
			}
		}

		/** Returns the [KotlinMetadata] of the closest parent javaElement (or this javaElement) that has one */
		internal fun getMetadata(elem: Element): KotlinMetadata?
				= elem.kotlinMetadata ?: elem.enclosingElement?.let(::getMetadata)
	}

	abstract val enclosingElement: KotlinElement?

	abstract val simpleName: Name

	abstract fun asType(): TypeMirror

	//TODO("visitor API")

	protected fun logW(s: String) = processingEnv.messager.printMessage(Diagnostic.Kind.WARNING, s)

	abstract override fun toString(): String
	abstract override fun equals(other: Any?): Boolean
	abstract override fun hashCode(): Int
}

